
# 

library(Ecdat)
library(Ecfun)
library(dplyr)
library(readxl)

## --- Reaction Time Data Wrangling ---
#Load data into R ----
ReactionTime <- read.table("/Users/fannyloof/Desktop/Assesment Measurment and Evaluation/MAE4000/data/RTdata.csv", header = T, sep = ";")

#when using the ID variable as the idvar argument, it complained it wasn't the unique value to the other variables, 
#so I removed duplicated rows
(ReactionTime.Clean <- ReactionTime[!duplicated(ReactionTime$ID),]) 

# Sorting columns in correct order
ReactionTime.Clean <- ReactionTime.Clean[, sort(names(ReactionTime.Clean))]

#Setting NA for RT = 0
#and also, where RT is 0, I choose to set to NA because it means that
#student didn't reach item in time, or didn't finish item on time
RTindex <- grep("^Time", names(ReactionTime.Clean)) 
ReactionTime.Clean[,RTindex][ReactionTime.Clean[,RTindex] == 0] <- NA

#Reshaping it into a long format
ReactionTime_long <- reshape(ReactionTime.Clean, direction = "long", idvar = "ID", varying = list(names(ReactionTime.Clean[,RTindex])))

#naming the variables according to instruction on canvas
names(ReactionTime_long) <- c("Group", "ID", "Item", "RT")

#Adding problems variable to dataframe
#needed function that rounds up(!) to nearest integer
ReactionTime_long$Problem <- ceiling(ReactionTime_long$Item / 4)


#Creating variables for subtotal in reaction time
ReactionTime.Clean$RTsub_01 <- rowSums(ReactionTime.Clean[,3:6], na.rm = T)
ReactionTime.Clean$RTsub_02 <- rowSums(ReactionTime.Clean[,7:10], na.rm = T)
ReactionTime.Clean$RTsub_03 <- rowSums(ReactionTime.Clean[,11:14], na.rm = T)
ReactionTime.Clean$RTsub_04 <- rowSums(ReactionTime.Clean[,15:18], na.rm = T)
ReactionTime.Clean$RTsub_05 <- rowSums(ReactionTime.Clean[,19:22], na.rm = T)
ReactionTime.Clean$RTsub_06 <- ReactionTime.Clean[,23]

#Creating a new dataframe out of new variables
RT.sub <- data.frame("ID" = ReactionTime.Clean$ID, "RTsub_01" = ReactionTime.Clean$RTsub_01, "RTsub_02" = ReactionTime.Clean$RTsub_02, "RTsub_03" = ReactionTime.Clean$RTsub_03, "RTsub_04" = ReactionTime.Clean$RTsub_04, "RTsub_05" = ReactionTime.Clean$RTsub_05, "RTsub_06"= ReactionTime.Clean$RTsub_06)

#Reshape from wide format to long
RT.sub_long <- reshape(RT.sub, direction = "long", idvar = "ID", varying = list(names(RT.sub[,2:7])))

#Creating problems variable out of variable time generated by reshape function
names(RT.sub_long) <- c("ID", "Problem", "RTsub")

#Creating dataframe for RT.tot 
RT.tot <- data.frame("RT.tot" = rowSums(ReactionTime.Clean[,RTindex], na.rm = T), "ID" = ReactionTime.Clean$ID)

#ordering ID in ascending by grouping items in ascending order 
RT.tot <- RT.tot[order(RT.tot$ID),]
RT.sub_long <- RT.sub_long[order(RT.sub_long$Problem),]

#merging dataframe with RTtot and RTsub
RTsub.RTtot <- merge(RT.sub_long,RT.tot, by = "ID")

#ordering ID in ascending by grouping items in ascending order 
RTsub.RTtot <- RTsub.RTtot[order(RTsub.RTtot$Problem),]

#merging to add extra variables to Reaction time dataset 
ReactionTime.allvar_long <- merge(RTsub.RTtot,ReactionTime_long, by = c("ID", "Problem"))

#putting ID in ascending order
ReactionTime.allvar_long <- ReactionTime.allvar_long[order(ReactionTime.allvar_long$ID),]


## ----- Test Score Data Wrangling ------

# Load data into a dataframe
Test.Score <- read_excel(path = "/Users/fannyloof/Desktop/Assesment Measurment and Evaluation/MAE4000/data/Ydata.xlsx", sheet = "Sheet1")

#using reg expression to rename items variables to give same name (some were named It etc)
names(Test.Score) <- gsub(pattern="^It_", replacement = "Item_", names(Test.Score))

#Need to change the names of columns to get them in increasing order
namestoreplace <- grep("_\\d$", names(Test.Score))
TSnames_vec1 <- gsub(pattern = "_", replacement = "_0", names(Test.Score[, namestoreplace]))
namestokeep <- grep("_\\d\\d$", names(Test.Score))
TSnames_vec2 <- gsub(pattern = "^Item_", replacement = "Item", names(Test.Score[, namestokeep]))
names(Test.Score) <- c("ID", TSnames_vec1, TSnames_vec2)

#Getting the variables in increasing order
#Trying a different method of getting the columns in preferred order
Test.Score <- Test.Score %>% select(order(names(Test.Score)))

#Setting values of Y to NA for items where RT = 0
Test.Score.NA <- merge(Test.Score,ReactionTime.Clean)
ColsNa <- colnames(Test.Score.NA)[colSums(is.na(Test.Score.NA)) > 0]
ColsNAind <- match(ColsNa, names(Test.Score.NA))

#Loop sets NA to items where corresponding RT = NA
for (num in ColsNAind){
  cols <- c(num-22, num)
  Test.Score.NA[ is.na(Test.Score.NA [ , cols[2] ]), ][, cols[1] ] <- NA
}

#Ridding all RT for dataset by subsetting the colums desired
Test.Score.Clean <- Test.Score.NA[, 1:23]

#getting the index of the names for the reshape function
TSindex <- grep("^Item", names(Test.Score.Clean))

#Test.Score dataframe was imported as a tibble, which didnÂ´t work for the reshape function, 
#so using the as.data.frame function to coerce it to be interpreted as a dataframe
Test.Score_long <- reshape(as.data.frame(Test.Score.Clean), direction = "long", idvar = "ID", varying = list(names(Test.Score[,TSindex])))

#naming the variables according to instruction on canvas
names(Test.Score_long) <- c("ID", "Group", "Item", "Y")

#Adding problems variable to dataframe
#needed function that rounds up(!) to nearest integer
Test.Score_long$Problem <- ceiling(Test.Score_long$Item / 4)

#creating Ytot variable 
Test.Score.Clean$Ytot <- rowSums(Test.Score.Clean[,TSindex])

#Creating six Ysub variables
Test.Score.Clean$Ysub_01 <- rowSums(Test.Score.Clean[,2:5], na.rm = T)
Test.Score.Clean$Ysub_02 <- rowSums(Test.Score.Clean[,6:9], na.rm = T)
Test.Score.Clean$Ysub_03 <- rowSums(Test.Score.Clean[,10:13], na.rm = T)
Test.Score.Clean$Ysub_04 <- rowSums(Test.Score.Clean[,14:17], na.rm = T)
Test.Score.Clean$Ysub_05 <- rowSums(Test.Score.Clean[,18:21], na.rm = T)
Test.Score.Clean$Ysub_06 <- Test.Score.Clean[,22]

#Creating a dataframe with only Ysubtotal and ID
Y.SUB <- data.frame("ID"=Test.Score.Clean$ID, "Ysub1" = Test.Score.Clean$Ysub_01, "Ysub2"= Test.Score.Clean$Ysub_02, "Ysub3"=Test.Score.Clean$Ysub_03, "Ysub4" = Test.Score.Clean$Ysub_04, "Ysub5"=Test.Score.Clean$Ysub_05, "Ysub6"=Test.Score.Clean$Ysub_06)

#Reshaping the created dataset into a long dataset
Ysub.ind <- grep("^Ysub", names(Y.SUB))
Y.SUB_long <- reshape(as.data.frame(Y.SUB), direction = "long", idvar = "ID", varying = list(names(Y.SUB[,Ysub.ind])))

#naming variables
names(Y.SUB_long) <- c("ID", "Problem", "Ysub")

#creating Ytot variable 
Test.Score.Clean$Ytot <- rowSums(Test.Score.Clean[,TSindex], na.rm = T)

#creating Ytot dataframe
Y.tot <- data.frame(Test.Score.Clean$Ytot, Test.Score.Clean$ID)
names(Y.tot) <- c("Ytot", "ID")

#Merging dataframes containing Y.tot and Y.sub
Ysub.Ytot <- merge(Y.tot, Y.SUB_long, by = "ID")

#ordering ID in ascending by grouping Problems in ascending order 
Ysub.Ytot_sort <- Ysub.Ytot[order(Ysub.Ytot$Problem),]

#merging to add extra variables to Test.Score dataset
Test.Score.allvar_long <- merge(Test.Score_long, Ysub.Ytot_sort, by = c("ID", "Problem"))

#putting ID in ascending order
Test.Score.allvar_long <- Test.Score.allvar_long[order(Test.Score.allvar_long$ID),]






## --- Merging Test Scores and Reaction Time datasets ----
Resultdf <- merge(Test.Score.allvar_long, ReactionTime.allvar_long)


# Splitting Group variable -----
LangGendf <- data.frame("ID" = Resultdf$ID, "LanguageGender"=Resultdf$Group)

#Creating a dataframe with ID coding for persons language and country
LangGendf_split <- data.frame(do.call(rbind, strsplit(LangGendf$LanguageGender, split = "_")))
LangGendf_split2 <- data.frame(do.call(rbind, strsplit(LangGendf_split$X2, split = "[A-Z]{2}$")))
LangGendf_split3 <- data.frame(do.call(rbind, strsplit(LangGendf_split$X2, split = "^[A-Z][a-z]+")))
LangGendf <- cbind(LangGendf_split, LangGendf_split2, LangGendf_split3)
LangGendf <- LangGendf[,-c(1,2,5)]
LangGendf$ID <- Resultdf$ID

names(LangGendf) <- c("country", "gender", "language", "ID")
LangGendf <- LangGendf[!duplicated(LangGendf$ID),]


# Merging Language df with Resultsdf
Resultdf1 <- merge(Resultdf, LangGendf)

Resultdf1 <- Resultdf1[,-c(3, 11)]
Resultdf1$gender <- as.factor(Resultdf1$gender)
Resultdf1$language <- as.factor(Resultdf1$language)


#Student with the highest score on top
Resultdf1 <- Resultdf1[order(Resultdf1$Ytot, decreasing = T),]

#export
write.table(Resultdf1, file = "FannyLoofWrangle.txt", sep = "\t", dec = ".", row.names = F)



